<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Harris</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Harris">
<meta property="og:url" content="https://github.com/isgonghang/isgonghang.github.io/index.html">
<meta property="og:site_name" content="Harris">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Harris">
  
    <link rel="alternate" href="/atom.xml" title="Harris" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Harris</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/isgonghang/isgonghang.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java初学-安装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/23/Java初学-安装/" class="article-date">
  <time datetime="2018-01-23T07:25:35.000Z" itemprop="datePublished">2018-01-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/23/Java初学-安装/">Java初学-安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在初次接触java开发的过程中，急于看到最终的结果，匆匆在网上下载了jdk之后，点击安装，结果等安装完，开始配置classpath时，发现jdk\lib下面根本就没有tools.jar和dt.jar 这两个包。我在首次遇到这样的问题时，也以为是下载的包有问题，于是重新下载了之后再安装，结果还是老样子。</p>
<p>问题的根本原因，我们没有弄清两个概念：JDK和JRE。JDK是java开发核心组件，是用来编译解释java程序的核心组件，包含java compile（javac）面向的是java开发人员。JRE是java运行环境。Java一种是跨平台语言，一次编译，多次在多台电脑上运行，这种机制主要依靠JVM实现。java程序编译得到的是中间字节码，中间字节码是不能再机器上直接运行的，必须要经过JVM把中间字节码转换为机器语言，事实上，JRE中主要包含的就是JVM。JRE是面向的是java程序用户。</p>
<p>搞清楚了JDK和JRE之后，在安装java相关的程序要当心了。在安装java包时，会遇到两次路径选择，第一次时选择jdk的路径，第二次是选择JRE的路径，如果把所选择的jdk的路径和jre的路径相同，那么jre包中的内容会覆盖掉jdk中的内容，因此，在你安装完成之后，会发现找不到tools.jar和dt.jar包。所以，在安装的过程中，jdk和jre要安装在不同的文件下，比如我的jdk安装在D:\java\jdk下面，jre安装在D:\java\jre下面。安装好之后，path和classpath的配置时针对JDK的，可以配置为：</p>
<p>Path=”D:\java\jdk\bin;”<br>classpath=”D:\java\jdk\lib\dt.jar;D:\java\jdk\lib\tools.jar;”<br>然后在cmd中输入javac，看到java命令帮助，表明java相关软件已经安装成功。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/isgonghang/isgonghang.github.io/2018/01/23/Java初学-安装/" data-id="cjcrdwy1y0005icvlflwayzy1" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-css居中布局总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/17/css居中布局总结/" class="article-date">
  <time datetime="2017-09-17T03:10:33.000Z" itemprop="datePublished">2017-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/17/css居中布局总结/">css居中布局总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>&lt;div class=&quot;parent&quot;&gt;
    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><p>1.inlink-block+text-align</p>
<pre><code>.child {display:inlink-block;}
.parent {text-align:center;}
</code></pre><p>优点：兼容性好<br>缺点：子元素宽高不可设置</p>
<p>2.table+margin</p>
<pre><code>.child {display:table; margin:0 auto;}
</code></pre><p>优点：只需要设置child（自己）</p>
<p>3.absolute+transform</p>
<pre><code>.parent {position:relative;}
.child {position:absolute;left:50%;transform:translateX(-50%);}
</code></pre><p>优点：子元素不会对其他元素产生影响<br>缺点：兼容性问题</p>
<p>4.flex+justify-content</p>
<pre><code>.parent {display:flex;justify-content:center;}
</code></pre><p>优点：只需设置parent节点<br>或者设置为</p>
<pre><code>.parent {display:flex;}
.child {margin:0 auto;}
</code></pre><p>缺点：flex低版本ie不支持</p>
<h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><p>1.table-cell+vertical-align</p>
<pre><code>.parent {display:table-cell;vertical-align:middle;}
</code></pre><p>优点：只需设置父节点，兼容性好</p>
<p>2.absolute+transform</p>
<pre><code>.parent {position:relative;}
.child {position:absolute;top:50%;transform:translateY(-50%);}
</code></pre><p>优点：子元素不会对其他元素产生影响<br>缺点：兼容性问题</p>
<p>3.flex+align-items</p>
<pre><code>.parent {display:flex;align-items:center;}
</code></pre><p>优点：只需设置父节点<br>缺点：兼容性问题</p>
<h2 id="水平和垂直均居中"><a href="#水平和垂直均居中" class="headerlink" title="水平和垂直均居中"></a>水平和垂直均居中</h2><p>1.inline-block+text-align+table-cell+vertical-align</p>
<pre><code>.parent {text-align:center;display:table-cell;vertical-align:middle;}
.child {display:inline-block;}
</code></pre><p>2.absolute+transform</p>
<pre><code>.parent {position:relative;}
.child { position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);}
</code></pre><p>3.flex+justify-content+align-items</p>
<pre><code>.parent {display:flex;justify-content:center;align-items:center;}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/isgonghang/isgonghang.github.io/2017/09/17/css居中布局总结/" data-id="cjcrdwy210007icvl6519mwdj" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-webpack深入与实战" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/25/webpack深入与实战/" class="article-date">
  <time datetime="2017-08-25T03:12:36.000Z" itemprop="datePublished">2017-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/25/webpack深入与实战/">webpack深入与实战</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>mrdir my-project                //创建文件
cd my-project                   //进入文件
npm init                        //初始化配置文件
npm install webpack --save-dev  //安装webpack
</code></pre><h2 id="基本打包命令"><a href="#基本打包命令" class="headerlink" title="基本打包命令"></a>基本打包命令</h2><pre><code>webpack hello.js hello.bundle.js
其中hello.js为自己编写的文件，hello.bundle.js为打包后文件
</code></pre><p>当打包css文件时，可以在文件内通过引入loader进行打包</p>
<pre><code>require(&apos;style-loader!css-loader!./style.css&apos;)
</code></pre><p>也可以在命令行中直接通过命令打包</p>
<pre><code>webpack hello.js hello.bundle.js --module-bind &apos;css=style-loader!css-loader&apos;
</code></pre><p>添加 –watch    命令可以动态观察文件变化并进行打包<br>     –progress  命令可以显示百分比读条<br>     –display-modules 可以列举出模块<br>     –display-reasons 可以列举出打包模块原因</p>
<pre><code>webpack hello.js hello.bundle.js --module-bind &apos;css=style-loader!css-loader&apos; --progress --display-modules --display-reasons --watch
</code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>配置文件是默认的文件名（webpack.config.js）</p>
<ol>
<li>在文件的根目录下创建webpack.config.js文件</li>
<li><p>配置参数</p>
<p> var path = require(‘path’);<br> module.exports = {</p>
<pre><code>entry:&apos;./src/script/main.js&apos;,//打包的入口
output:{
    path: path.resolve(__dirname, &apos;dist/js&apos;),//打包后的存放路径     （绝对路径）
    filename:&apos;bundle.js&apos;//打包后的文件名
}
</code></pre><p> }</p>
</li>
</ol>
<ol>
<li>在命令行 中运行：webpack</li>
</ol>
<p><strong>配置文件不是默认的文件名</strong></p>
<ol>
<li>比如配置文件的文件名为webpack.dev.config.js</li>
<li>在命令行中运行时：webpack –config webpack.dev.config.js</li>
</ol>
<p><strong>设置webpack参数</strong></p>
<ol>
<li>在npm脚本文件package.json文件中设置</li>
<li>在scripts中添加：”webpack”:”webpack –config webpack.config.js –progress –display-modules –colors –display-reasons”</li>
</ol>
<h2 id="webpack的三种用法"><a href="#webpack的三种用法" class="headerlink" title="webpack的三种用法"></a>webpack的三种用法</h2><p>1.直接命令行使用。<br>2.node.js API的使用方式。<br>3.webpack —config webpack.config.js </p>
<p><strong>entry</strong></p>
<p>entry用于定义入口文件</p>
<p>1.三种输入方式</p>
<p>（1）string，输入字符串<br>    entry:{<br>        main:’./src/script/main.js’<br>    },</p>
<p>（2）array, 数组。适用情况：两个平行的，不相依赖的文件打包在一起。<br>    entry:{<br>        main:[‘./src/script/main.js’,’./src/script/a.js’]<br>    },</p>
<p>（3）object, 适用情况：多页面应用程序。这里要和output里的[name]占位符配合使用，威力才能最大。如果你要打包成多个js文件，那么entry对象里的key叫做chunk就是文件名，里面的值就是需要打包的文件里面包含的文件。<br>    entry:{<br>        main:’./src/script/main.js’,<br>        a:’./src/script/a.js’<br>    },</p>
<p><strong>output</strong></p>
<p>1.占位符有3种：[name]、[hash]、[chunkhash]</p>
<p>2.output的filename<br>（1）hash: 这次打包的hash<br>每次终端运行webpack命令，都会生成一段信息，这段信息的第一行就有一个hash<br>（2）chunkhash:每一个chunk自己的hash</p>
<p>3.output的path，//这里配置的是输出的文件地址</p>
<h2 id="自动生成html页面"><a href="#自动生成html页面" class="headerlink" title="自动生成html页面"></a>自动生成html页面</h2><p>html中引入script，如果是hash或者chunkhash生成的js，则src每次都要修改，避免修改的方法就是用webpack的插件：</p>
<p>1.安装webpack插件：<br>终端项目目录输入：npm install html-webpack-plugin –save-dev</p>
<p>2.配置文件中建立对插件的引用<br>webpack.config.js中<br>（1）引用插件</p>
<pre><code>var htmlWebpackPlugin=require(&apos;htmll-webpack-plugin&apos;);
</code></pre><p>（2）以index.html为模板</p>
<pre><code>设置plugins:[
    new htmlWebpackPlugin()// 初始化插件
]
</code></pre><p>这里的代码只会让webpack自动生成一个index.html，里面自动把js代码插入到index.html当中。//注意，这里说的是webpack生成的index.html，不是你自定义的index.html。<br>要想让生成的index.html是自定义的，那么就要设置</p>
<pre><code>plugins:[
    new htmlWebpackPlugin({
        template: ‘index.html’,//   这里的index.html就是根目录下的index.html文件，是你自己写的文件。
        filename: ‘index-[hash].html’,//这里指定的是生成的文件的名字
         inject: &apos;body’,// 这里可以指定js文件是放在head还是body标签里面具体还可  以放哪，请看文档说明。https://github.com/jantimon/   html-webpack-plugin#configuration
    })// 初始化插件
]
</code></pre><p>（4）webpack使用插件的地址是根据配置里的context，上下文来决定的。</p>
<p>（5）文件生成在dist下，而不是一直在js下<br>    output:{<br>        path:path.resolve(__dirname,’./dist’),<br>        filename:’js/[name]-[chunkhash].js’//js文件生成到js文件夹中<br>    },</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/isgonghang/isgonghang.github.io/2017/08/25/webpack深入与实战/" data-id="cjcrdwy250009icvls0kup4pv" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript正则表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/18/JavaScript正则表达式/" class="article-date">
  <time datetime="2017-08-18T13:49:18.000Z" itemprop="datePublished">2017-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/18/JavaScript正则表达式/">JavaScript正则表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>正则表达式是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。这些模式被用于RegExp的exec和test方法,以及String的match、replace、search和split方法。</p>
<h2 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h2><p>有两种方法可以构建一个正则表达式：</p>
<p>1.使用一个正则表达式字面量，其由包含在斜杠之间的模式组成：</p>
<pre><code>var reg = /pattern/flags
</code></pre><p>2.调用RegExp对象的构造函数:</p>
<pre><code>var reg = new RegExp(pattern, [,flags])
</code></pre><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>元字符是在正则表达式中有特殊意义的非字母字符，包括：</p>
<pre><code>* + ? ^ $ . | \ ( ) { } []
</code></pre><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p>类是指符合某些特性的对象，一个泛指，而不是特指某个字符</p>
<pre><code>可以使用元字符[]来构建一个简单的类
例如：[abc]
</code></pre><p>可以使用元字符^创建反向类(不属于某类的内容)</p>
<pre><code>例如 [^abc] 表示不是a或b或c的内容
</code></pre><h2 id="范围类"><a href="#范围类" class="headerlink" title="范围类"></a>范围类</h2><pre><code>可以使用[a-z]来连接两个字符表示从a到z的任意字符
可以连写 [a-zA-Z]
</code></pre><h2 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h2><p>包括 . \d \D \s \S \w \W等，具体含义查阅MDN<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">MDN正则表达式</a></p>
<p><strong>边界字符：^(以xxx开始)、$(以xxx结束)、\b(单词边界)、\B(非单词边界)</strong></p>
<h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><pre><code>量词包括 ?(出现0次或1次，最多出现一次) 
         +(出现1次或多次，至少出现一次) 
         *(出现0次或多次，任意次) 
         {n}(出现n次)
         {n,m}(出现n到m次)
         {n,}(至少出现n次)
</code></pre><h2 id="贪婪模式和非贪婪模式"><a href="#贪婪模式和非贪婪模式" class="headerlink" title="贪婪模式和非贪婪模式"></a>贪婪模式和非贪婪模式</h2><p>当指定一个\d{3,6}时，正则表达式默认为贪婪模式，会尽可能多的匹配(6次)</p>
<p>在量词后面加上?可以切换到非贪婪模式，正则表达式会尽可能少的匹配</p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>使用()可以达到分组的功能，使量词作用于分组</p>
<pre><code>例如：a1b2c3d4.replace(/[a-z]\d{3}/g, &apos;x&apos;)只会匹配到数字
而使用a1b2c3d4.replace(/([a-z]\d){3}/g, &apos;x&apos;)则会替换为xd4
</code></pre><h2 id="前瞻"><a href="#前瞻" class="headerlink" title="前瞻"></a>前瞻</h2><p>正则表达式从文本头部向尾部开始解析，文本尾部方向，成为’前’</p>
<p>前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言</p>
<p>后顾方向相反，但JavaScript不支持后顾</p>
<pre><code>正向前瞻 exp(?=assert)
负向前瞻 exp(?!assert)
例如: &apos;a2*3&apos; .replace(/\w(?=\d)/g, &apos;x&apos;)
</code></pre><h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h2><pre><code>g  全文搜索
i  忽略大小写
m  多行搜索
lastIndex  当前表达式匹配内容的最后一个字符的下一个位置
</code></pre><h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test" target="_blank" rel="noopener">test()</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec" target="_blank" rel="noopener">exec()</a></p>
<p>字符串对象方法:<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match" target="_blank" rel="noopener">match()</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="noopener">replace()</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search" target="_blank" rel="noopener">search()</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/isgonghang/isgonghang.github.io/2017/08/18/JavaScript正则表达式/" data-id="cjcrdwy1w0004icvlni9via5g" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习Javascript闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/25/学习Javascript闭包/" class="article-date">
  <time datetime="2017-07-25T08:14:23.000Z" itemprop="datePublished">2017-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/25/学习Javascript闭包/">学习Javascript闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>看了很多博客，闭包被定义的非常抽象，很难看懂。<br>我的理解，闭包就是外部能够读取其他函数内部变量的函数。</p>
<p><strong>首先，就要了解作用域。</strong><br>Javascript作用域分为两种：<strong>全局作用域</strong>和 <strong>局部作用域（函数作用域）</strong>。</p>
<p>而由于特殊的作用域链，子函数内部可以读取父函数（全局作用域）的变量。<br>另一方面，父函数却无法读取子函数作用域内部变量。</p>
<pre><code>var x=000;
function demo1(){
    alert(x);       //子函数访问全局作用域中的x
}
demo1();    //000

function demo2(){
    var x=000;
}
alert(x);           //错误 函数外部无法访问函数内局部变量
</code></pre><p>要使函数外部读取函数内的局部变量，可以通过在函数（demo1）内部再定义一个函数（demo2）并将其（demo2）作为返回值，</p>
<pre><code>function demo1(){
    var x=000;
    function demo2(){
        alert(x);
    }
    return demo2;
}
var result=demo1();
result();   //000
</code></pre><p><strong>在上面的代码中，函数demo2定义在函数demo1内部，这是demo1内部的局部变量demo2都可以访问到，但如果不将demo2作为返回值，反过来demo1就无法访问demo2的内部局部变量。</strong><br><strong>这是因为Javascript的 链式作用域结构：每当创建一个子函数，子函数就会沿着作用域链一级一级的向上寻找并访问到父函数的局部变量。反之，子函数内部的局部变量对父函数都是不可见的。</strong><br><strong>所以代码中的demo2函数就是闭包，它允许父函数访问子函数内部的局部变量。</strong></p>
<p><strong>闭包的用途</strong><br>闭包的作用有两个：一是可以使父函数读取子函数内部的局部变量，二是让这些变量始终保存在内存中，在调用结束后不会被垃圾回收机制回收。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/isgonghang/isgonghang.github.io/2017/07/25/学习Javascript闭包/" data-id="cjcrdwy26000aicvlvwr0free" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-setTimeOut引发的异步函数思考" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/20/setTimeOut引发的异步函数思考/" class="article-date">
  <time datetime="2017-07-20T06:29:40.000Z" itemprop="datePublished">2017-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/20/setTimeOut引发的异步函数思考/">setTimeOut引发的异步函数思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天在博客上看到了一篇setTimeOut异步函数的文章，正好自己也不是很清楚，看完后感觉启发很大。</p>
<h2 id="JavaScript运行环境"><a href="#JavaScript运行环境" class="headerlink" title="JavaScript运行环境"></a>JavaScript运行环境</h2><p>JS是单线程的，意思就是 <strong>同一时刻只能做一件事情。</strong><br>但是要如何同时响应不同的操作呢？<br>先以BOSS来称呼JS的主线程，Boss为了更多更快地处理用户的需求，会不停地接收任务来执行。为了进一步提交效率，他 <strong>优先执行最紧急的任务（即刻要执行）</strong>，如果你要和他说”等下（3秒后 / 如果有我点了按钮 / 如果收到了服务器的响应）帮我在控制台打一个log吧。”，BOSS不会专门等着去执行你的需求，而是默默地把你这个”伪需求”记在一个”小本本”上，然后拍拍胸脯和你说：”我保证(I promise!)”，接着继续做手头上的事，等BOSS手头上事情做完了，会从小本本上选择 <strong>最早记录的没被执行</strong>的任务来执行。</p>
<p>BOSS能力和时间有限，能做的只有这么多了。他Promise会帮你做的任务肯定会做（只要他没有猝死。。），但时间上可能并不一定严格符合你的要求，毕竟小本本上可能不仅只有一条任务。</p>
<h2 id="理解setTimeOut"><a href="#理解setTimeOut" class="headerlink" title="理解setTimeOut"></a>理解setTimeOut</h2><p>上面的小故事中的称呼分别为：</p>
<pre><code>JS主线程 =&gt; BOSS
同步任务 =&gt; BOSS手头上正在做的任务
异步任务（队列） =&gt; BOSS的小本本上的任务
</code></pre><p>我以前只知道setTimeout的意思让JS从现在开始，经过指定的时间后，执行相应的函数。</p>
<p>从方法名和大部分现象来看，很容易产生以上的误解。在我们理解了JS主线程的特点后，知道了它会优先完成同步任务，在同步任务执行过程中，不会执行其它任务。</p>
<p>实际上，setTimeout做的事情是：<strong>在指定delay时间后，将指定方法作为异步任务添加到异步任务队列中。</strong></p>
<p>所以，如果setTimeout的定时到了执行时间，JS主线程仍然还在执行同步任务，setTimeout所指定的方法并不会立刻执行。</p>
<p>而且即使JS主线程执行完了同步任务，也不一定会执行setTimeout指定的方法，因为异步任务队列中可能有更早加入的异步任务。</p>
<p>除了setTimeout还有一个setInterval,setInterval可以通过设置的时间向主线程添加异步任务，但最重要的是：<strong>setInterval会检测待执行队列中的异步任务，防止重复添加，但是并不会检测正在执行的异步任务。</strong></p>
<p>防止重复定时：</p>
<pre><code>setTimeout(function() {
    doWhatYouWantTo();
    setTimeout(arguments.callee, 100)
}, 100);
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/isgonghang/isgonghang.github.io/2017/07/20/setTimeOut引发的异步函数思考/" data-id="cjcrdwy230008icvlrkxnhqlk" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-cookie、localStorage、sessionStorage理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/18/cookie、localStorage、sessionStorage理解/" class="article-date">
  <time datetime="2017-07-18T08:04:19.000Z" itemprop="datePublished">2017-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/18/cookie、localStorage、sessionStorage理解/">cookie、localStorage、sessionStorage理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>浏览器存储的方式主要有三种：cookie、localStorage和sessionStorage。<br><strong>查阅MDN文档</strong></p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>HTTP Cookie（也叫Web cookie或者浏览器Cookie）是服务器发送到用户浏览器并保存在浏览器上的一块数据，它会在浏览器下一次发起请求时被携带并发送到服务器上。比较经典的，可以它用来确定两次请求是否来自于同一个浏览器，从而能够确认和保持用户的登录状态。Cookie的使用使得基于无状态的HTTP协议上记录稳定的状态信息成为了可能。</p>
<p><strong>Cookie主要用在以下三个方面:</strong></p>
<p>1.会话状态管理（如用户登录状态、购物车）<br>2.个性化设置（如用户自定义设置）<br>3.浏览器行为跟踪（如跟踪分析用户行为）</p>
<p>Cookie可用于客户端数据的存储，在没有其它存储办法时，使用这种方式是可行的，但随着现在浏览器开始支持各种各样的存储方式而逐渐被废弃。由于服务器指定Cookie以后浏览器的每次请求都会携带Cookie数据，这会带来额外的性能负担（尤其是在移动环境下）。新的浏览器API已经允许开发者直接在本地存储数据，如可以使用Web storage API （本地存储localStorage和会话存储sessionStorage）和IndexedDB。</p>
<p><strong>创建cookie</strong><br>当服务器收到HTTP请求时，可以在响应头里面增加一个Set-Cookie头部。浏览器收到响应之后会取出Cookie信息并保存，之后对该服务器每一次请求中都通过Cookie请求头部将Cookie信息发送给服务器。另外，Cookie的过期时间、域、路径、有效期、站点都可以根据需要来指定。</p>
<pre><code>Set-Cookie: &lt;cookie名称&gt;=&lt;cookie值&gt;
</code></pre><p>创建cookie时可以制定cookie的键值对、过期时间(expires)或有效期(Max-age)、作用域(domain和path)。</p>
<p>在JS代码中可以通过document.cookie来创建新的cookie或访问cookie。</p>
<h2 id="localStorage-amp-sessionStorage"><a href="#localStorage-amp-sessionStorage" class="headerlink" title="localStorage&amp;sessionStorage"></a>localStorage&amp;sessionStorage</h2><p>localStorage 属性允许你访问一个localStorage对象。localStorage与sessionStorage 相似。不同之处在于，<strong>存储在 localStorage里面的数据没有过期时间expiration time），而存储在 sessionStorage里面的数据会在浏览器会话（browsing session）结束时被清除，即浏览器关闭时。</strong></p>
<p>应该注意的是，无论是localStorage还是sessionStorage中保存的数据都仅限于该页面的协议。</p>
<pre><code>myStorage = localStorage;
</code></pre><p>使用Storage.setItem()方法往里面添加一个数据项。</p>
<pre><code>localStorage.setItem(&apos;myCat&apos;, &apos;Tom&apos;);
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/isgonghang/isgonghang.github.io/2017/07/18/cookie、localStorage、sessionStorage理解/" data-id="cjcrdwy1z0006icvlmtef7srk" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-排序算法汇总" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/23/排序算法汇总/" class="article-date">
  <time datetime="2017-05-23T09:31:31.000Z" itemprop="datePublished">2017-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/排序算法汇总/">排序算法汇总</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>此文章参考自阮一峰JavaScript教程</strong></p>
<p>排序算法是将一系列的值按照顺序进行排列的方法。最主要的排序算法有以下几种：</p>
<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>合并排序</li>
<li><strong>快速排序</strong></li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubbl Sort）是最易懂的排序算法，但是效率较低，生产环境中很少使用。</p>
<p><strong>基本算法思想：</strong></p>
<p>1.依次比较相邻的两个数，如果不符合排序规则，则调换两个数的位置。这样一遍比较下来，能够保证最大（或最小）的数排在最后一位。</p>
<p>2.再对最后一位以外的数组，重复前面的过程，直至全部排序完成。</p>
<p>由于每进行一次这个过程，在该次比较的最后一个位置上，正确的数会自己冒出来，就好像“冒泡”一样，这种算法因此得名。</p>
<p><strong>以对数组[3, 2, 4, 5, 1]进行从小到大排序为例，步骤如下：</strong></p>
<p>1.第一位的“3”与第二位的“2”进行比较，3大于2，互换位置，数组变成[2, 3, 4, 5, 1]。</p>
<p>2.第二位的“3”与第三位的“4”进行比较，3小于4，数组不变。</p>
<p>3.第三位的“4”与第四位的“5”进行比较，4小于5，数组不变。</p>
<p>4.第四位的“5”与第五位的“1”进行比较，5大于1，互换位置，数组变成[2, 3, 4, 1, 5]。</p>
<p>第一轮排序完成，可以看到最后一位的5，已经是正确的数了。然后，再对剩下的数[2, 3, 4, 1]重复这个过程，每一轮都会在本轮最后一位上出现正确的数。直至剩下最后一个位置，所有排序结束。</p>
<p><strong>代码实现</strong></p>
<p>先定义一个交换函数，作用是交换两个位置的值。</p>
<pre><code>function swap(myArray, p1, p2){
  var temp = myArray[p1];    //先定义变量temp，将数组p1位置的值赋值给temp
  myArray[p1] = myArray[p2]; //将p2位置的值赋值给p1位置
  myArray[p2] = temp;        //再将temp(即数组p1位置的值)赋值给p2，完成交换
}
</code></pre><p>然后定义主函数。</p>
<pre><code>function bubbleSort(myArray){
  var len = myArray.length;
  var i;
  var j;
  var stop;
  //循环数组 
  for (i = 0; i &lt; len - 1; i++){
    //循环当前循环位置以后数组剩余其他元素
    for (j = 0, stop = len - 1 - i; j &lt; stop; j++){
      //比较j和j+1位的大小，如果符合交换规则则调用交换函数
      if (myArray[j] &gt; myArray[j + 1]){ 
        swap(myArray, j, j + 1);
      }
    }
  }

  return myArray;
}
</code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>基本算法思想：</strong></p>
<p><strong>选择排序（Selection Sort）与冒泡排序类似，也是依次对相邻的数进行两两比较。不同之处在于，它不是每比较一次就调换位置，而是一轮比较完毕，找到最大值（或最小值）之后，将其放在正确的位置，其他数的位置不变。</strong></p>
<p><strong>以对数组[3, 2, 4, 5, 1] 进行从小到大排序为例，步骤如下：</strong></p>
<p>1.假定第一位的“3”是最小值。</p>
<p>2.最小值“3”与第二位的“2”进行比较，2小于3，所以新的最小值是第二位的“2”。</p>
<p>3.最小值“2”与第三位的“4”进行比较，2小于4，最小值不变。</p>
<p>4.最小值“2”与第四位的“5”进行比较，2小于5，最小值不变。</p>
<p>5.最小值“2”与第五位的“1”进行比较，1小于2，所以新的最小值是第五位的“1”。</p>
<p>6.第五位的“1”与第一位的“3”互换位置，数组变为[1, 2, 4, 5, 3]。</p>
<p>这一轮比较结束后，最小值“1”已经排到正确的位置了，然后对剩下的[2, 4, 5, 3]重复上面的过程。每一轮排序都会将该轮的最小值排到正确的位置，直至剩下最后一个位置，所有排序结束。</p>
<p><strong>代码实现</strong></p>
<p>先定义一个交换函数，作用是交换两个位置的值。</p>
<pre><code>function swap(myArray, p1, p2){
  var temp = myArray[p1];    //先定义变量temp，将数组p1位置的值赋值给temp
  myArray[p1] = myArray[p2]; //将p2位置的值赋值给p1位置
  myArray[p2] = temp;        //再将temp(即数组p1位置的值)赋值给p2，完成交换
}
</code></pre><p>然后定义主函数。</p>
<pre><code>function selectionSort(myArray){

    var len = myArray.length,
        min;
    for (i=0; i &lt; len; i++){
        // 将当前位置设为最小值
        min = i;
        // 检查数组其余部分是否更小
        for (j=i+1; j &lt; len; j++){
            if (myArray[j] &lt; myArray[min]){
                min = j;
            }
        }
        // 如果当前位置不是最小值，将其换为最小值
        if (i != min){
            swap(myArray, i, min);
        }
    }
    return myArray;
}
</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>基本算法思想：</strong></p>
<p><strong>插入排序（insertion sort）比前面两种排序方法都更有效率。它将数组分成“已排序”和“未排序”两部分，一开始的时候，“已排序”的部分只有一个元素，然后将它后面一个元素从“未排序”部分插入“已排序”部分，从而“已排序”部分增加一个元素，“未排序”部分减少一个元素。以此类推，完成全部排序。</strong></p>
<p><strong>以对数组[3, 2, 4, 5, 1] 进行从小到大排序为例，步骤如下：</strong></p>
<p>1.将数组分成[3]和[2, 4, 5, 1]两部分，前者是已排序的，后者是未排序的。</p>
<p>2.取出未排序部分的第一个元素“2”，与已排序部分最后一个元素“3”比较，因为2小于3，所以2排在3前面，整个数组变成[2, 3]和[4, 5, 1]两部分。</p>
<p>3.取出未排序部分的第一个元素“4”，与已排序部分最后一个元素“3”比较，因为4大于3，所以4排在3后面，整个数组变成[2, 3, 4]和[5, 1]两部分。</p>
<p>4.取出未排序部分的第一个元素“5”，与已排序部分最后一个元素“4”比较，因为5大于4，所以5排在4后面，整个数组变成[2, 3, 4, 5]和[1]两部分。</p>
<p>5.取出未排序部分的第一个元素“1”，与已排序部分最后一个元素“5”比较，因为1小于5，所以再与前一个元素“4”比较；因为1小于4，再与前一个元素“3”比较；因为1小于3，再与前一个元素“2”比较；因为小于1小于2，所以“1”排在2的前面，整个数组变成[1, 2, 3, 4, 5]。</p>
<p><strong>代码实现</strong></p>
<pre><code>function insertionSort(myArray) {

    var len     = myArray.length,     // 数组的长度
        value,                      // 当前比较的值
        i,                          // 未排序部分的当前位置
        j;                          // 已排序部分的当前位置

    for (i=0; i &lt; len; i++) {

        // 储存当前位置的值
        value = myArray[i];

        /*
         * 当已排序部分的当前元素大于value，
         * 就将当前元素向后移一位，再将前一位与value比较
         */
        for (j=i-1; j &gt; -1 &amp;&amp; myArray[j] &gt; value; j--) {
            myArray[j+1] = myArray[j];
        }

        myArray[j+1] = value;
    }

    return myArray;
}
</code></pre><h2 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h2><p><strong>基本算法思想：</strong></p>
<p>前面三种排序算法只有教学价值，因为效率低，很少实际使用。合并排序（Merge sort）则是一种被广泛使用的排序方法。</p>
<p><strong>它的基本思想是，将两个已经排序的数组合并，要比从头开始排序所有元素来得快。因此，可以将数组拆开，分成n个只有一个元素的数组，然后不断地两两合并，直到全部排序完成。</strong></p>
<p><strong>以对数组[3, 2, 4, 5, 1] 进行从小到大排序为例，步骤如下：</strong></p>
<p>1.将数组分成[3, 2, 4]和[5, 1]两部分。</p>
<p>2.将[3, 2, 4]分成[3, 2]和[4]两部分。</p>
<p>3.将[3, 2]分成[3]和[2]两部分，然后合并成[2, 3]。</p>
<p>4.将[2, 3]和[4]合并成[2, 3, 4]。</p>
<p>5.将[5, 1]分成[5]和[1]两部分，然后合并成[1, 5]。</p>
<p>6.将[2, 3, 4]和[1, 5]合并成[1, 2, 3, 4, 5]</p>
<p><strong>代码实现</strong></p>
<p>这里的关键是如何合并两个已经排序的数组。具体实现请看下面的函数。</p>
<pre><code>function merge(left, right){
    var result  = [],
        il      = 0,
        ir      = 0;

    while (il &lt; left.length &amp;&amp; ir &lt; right.length){
        if (left[il] &lt; right[ir]){
            result.push(left[il++]);
        } else {
            result.push(right[ir++]);
        }
    }

    return result.concat(left.slice(il)).concat(right.slice(ir));
}
</code></pre><p>上面的merge函数，合并两个已经按升序排好序的数组。首先，比较两个数组的第一个元素，将其中较小的一个放入result数组；然后，将其中较大的一个与另一个数组的第二个元素进行比较，再将其中较小的一个放入result数组的第二个位置。以此类推，直到一个数组的所有元素都进入result数组为止，再将另一个数组剩下的元素接着result数组后面返回（使用concat方法）。</p>
<p>有了merge函数，就可以对任意数组排序了。基本方法是将数组不断地拆成两半，直到每一半只包含零个元素或一个元素为止，然后就用merge函数，将拆成两半的数组不断合并，直到合并成一整个排序完成的数组。</p>
<pre><code>function mergeSort(myArray){

    if (myArray.length &lt; 2) {
        return myArray;
    }

    var middle = Math.floor(myArray.length / 2),
        left    = myArray.slice(0, middle),
        right   = myArray.slice(middle);

    return merge(mergeSort(left), mergeSort(right));
}
</code></pre><p>上面的代码有一个问题，就是返回的是一个全新的数组，会多占用空间。因此，修改上面的函数，使之在原地排序，不多占用空间。</p>
<pre><code>function mergeSort(myArray){

    if (myArray.length &lt; 2) {
        return myArray;
    }

    var middle = Math.floor(myArray.length / 2),
        left    = myArray.slice(0, middle),
        right   = myArray.slice(middle),
        params = merge(mergeSort(left), mergeSort(right));

    // 在返回的数组头部，添加两个元素，第一个是0，第二个是返回的数组长度
    params.unshift(0, myArray.length);

    // splice用来替换数组元素，它接受多个参数，
    //  第一个是开始替换的位置，第二个是需要替换的个数，后面就是所有新加入的元素。
    // 因为splice不接受数组作为参数，所以采用apply的写法。
    // 这一句的意思就是原来的myArray数组替换成排序后的myArray
    myArray.splice.apply(myArray, params);

    // 返回排序后的数组
    return myArray;
}
</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>基本算法思想：</strong></p>
<p><strong>快速排序（quick sort）是公认最快的排序算法之一，有着广泛的应用。</strong></p>
<p>它的基本思想很简单：先确定一个“支点”（pivot），将所有小于“支点”的值都放在该点的左侧，大于“支点”的值都放在该点的右侧，然后对左右两侧不断重复这个过程，直到所有排序完成。</p>
<p>具体做法是：</p>
<p>1.确定“支点”（pivot）。虽然数组中任意一个值都能作为“支点”，但通常是取数组的中间值。</p>
<p>2.建立两端的指针。左侧的指针指向数组的第一个元素，右侧的指针指向数组的最后一个元素。</p>
<p>3.左侧指针的当前值与“支点”进行比较，如果小于“支点”则指针向后移动一位，否则指针停在原地。</p>
<p>4.右侧指针的当前值与“支点”进行比较，如果大于“支点”则指针向前移动一位，否则指针停在原地。</p>
<p>5.左侧指针的位置与右侧指针的位置进行比较，如果前者大于等于后者，则本次排序结束；否则，左侧指针的值与右侧指针的值相交换。</p>
<p>6.对左右两侧重复第2至5步。</p>
<p><strong>以对数组[3, 2, 4, 5, 1] 进行从小到大排序为例，步骤如下：</strong></p>
<p>1.选择中间值“4”作为“支点”。</p>
<p>2.第一个元素3小于4，左侧指针向后移动一位；第二个元素2小于4，左侧指针向后移动一位；第三个元素4等于4，左侧指针停在这个位置（数组的第2位）。</p>
<p>3.倒数第一个元素1小于4，右侧指针停在这个位置（数组的第4位）。</p>
<p>4.左侧指针的位置（2）小于右侧指针的位置（4），两个位置的值互换，数组变成[3, 2, 1, 5, 4]。</p>
<p>5.左侧指针向后移动一位，第四个元素5大于4，左侧指针停在这个位置（数组的第3位）。</p>
<p>6.右侧指针向前移动一位，第四个元素5大于4，右侧指针移动向前移动一位，第三个元素1小于4，右侧指针停在这个位置（数组的第3位）。</p>
<p>7.左侧指针的位置（3）大于右侧指针的位置（2），本次排序结束。</p>
<p>8.对 [3, 2, 1]和[5, 4]两部分各自不断重复上述步骤，直到排序完成。</p>
<p><strong>代码实现</strong></p>
<p>首先部署一个swap函数，用于互换两个位置的值。</p>
<pre><code>function swap(myArray, firstIndex, secondIndex){
    var temp = myArray[firstIndex];
    myArray[firstIndex] = myArray[secondIndex];
    myArray[secondIndex] = temp;
}
</code></pre><p>然后，部署一个partition函数，用于完成一轮排序。</p>
<pre><code>function partition(myArray, left, right) {

    var pivot   = myArray[Math.floor((right + left) / 2)],
        i       = left,
        j       = right;


    while (i &lt;= j) {

        while (myArray[i] &lt; pivot) {
            i++;
        }

        while (myArray[j] &gt; pivot) {
            j--;
        }

        if (i &lt;= j) {
            swap(myArray, i, j);
            i++;
            j--;
        }
    }

    return i;
}
</code></pre><p>接下来，就是递归上面的过程，完成整个排序。</p>
<pre><code>function quickSort(myArray, left, right) {

    if (myArray.length &lt; 2) return myArray;

    left = (typeof left !== &quot;number&quot; ? 0 : left);

    right = (typeof right !== &quot;number&quot; ? myArray.length - 1 : right);

    var index  = partition(myArray, left, right);

     if (left &lt; index - 1) {
            quickSort(myArray, left, index - 1);
     }

     if (index &lt; right) {
            quickSort(myArray, index, right);
      }

     return myArray;

}
</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Nicholas C. Zakas, <a href="https://www.nczonline.net/blog/2009/05/26/computer-science-in-javascript-bubble-sort/" target="_blank" rel="noopener">Computer science in JavaScript: Bubble sort</a></li>
<li>Nicholas C. Zakas, <a href="http://www.nczonline.net/blog/2012/09/17/computer-science-in-javascript-insertion-sort/" target="_blank" rel="noopener">Computer science in JavaScript: Bubble sort</a></li>
<li>Nicholas C. Zakas, <a href="https://www.nczonline.net/blog/2012/09/17/computer-science-in-javascript-insertion-sort/" target="_blank" rel="noopener">Computer science in JavaScript: Bubble sort</a></li>
<li>Nicholas C. Zakas, <a href="https://www.nczonline.net/blog/2012/10/02/computer-science-and-javascript-merge-sort/" target="_blank" rel="noopener">Computer science in JavaScript: Bubble sort</a></li>
<li>Nicholas C. Zakas, <a href="https://www.nczonline.net/blog/2012/11/27/computer-science-in-javascript-quicksort/" target="_blank" rel="noopener">Computer science in JavaScript: Bubble sort</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/isgonghang/isgonghang.github.io/2017/05/23/排序算法汇总/" data-id="cjcrdwy2c000cicvlwihl71qr" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-浏览器同源策略与CORS跨域" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/21/浏览器同源策略与CORS跨域/" class="article-date">
  <time datetime="2017-05-21T06:26:44.000Z" itemprop="datePublished">2017-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/21/浏览器同源策略与CORS跨域/">浏览器同源策略与CORS跨域</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h2><pre><code>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。
</code></pre><p><strong>一个源的定义</strong></p>
<pre><code>如果协议，端口（如果指定了一个）和域名对于两个页面是相同的，则两个页面具有相同的源。
例如www.google.com:80/index/package.json中，只要主域名(www)，子域名(google.com),端口(80)中有一个不相同，都属于非同源。
</code></pre><table>
<thead>
<tr>
<th>URL</th>
<th style="text-align:center">结果</th>
<th style="text-align:right">原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://store.company.com/dir2/other.html" target="_blank" rel="noopener">http://store.company.com/dir2/other.html</a></td>
<td style="text-align:center">成功</td>
<td style="text-align:right">dir2/other.html</td>
</tr>
<tr>
<td><a href="http://store.company.com/dir/inner/another.html" target="_blank" rel="noopener">http://store.company.com/dir/inner/another.html</a></td>
<td style="text-align:center">成功</td>
<td style="text-align:right">dir/inner/another.html</td>
</tr>
<tr>
<td><a href="https://store.company.com/secure.html" target="_blank" rel="noopener">https://store.company.com/secure.html</a></td>
<td style="text-align:center">失败</td>
<td style="text-align:right">不同的协议/https</td>
</tr>
<tr>
<td><a href="http://store.company.com:81/dir/etc.html" target="_blank" rel="noopener">http://store.company.com:81/dir/etc.html</a></td>
<td style="text-align:center">失败</td>
<td style="text-align:right">不同的端口/81</td>
</tr>
<tr>
<td><a href="http://news.company.com/dir/other.html" target="_blank" rel="noopener">http://news.company.com/dir/other.html</a></td>
<td style="text-align:center">失败</td>
<td style="text-align:right">不同的域名/news</td>
</tr>
</tbody>
</table>
<p><strong>IE例外</strong></p>
<ul>
<li>授信范围（Trust Zones）：两个相互之间高度互信的域名，如公司域名（corporate domains），不遵守同源策略的限制。</li>
<li><p>端口：IE未将端口号加入到同源策略的组成部分之中，因此 <a href="http://company.com:81/index.html" target="_blank" rel="noopener">http://company.com:81/index.html</a> 和<a href="http://company.com/index.html" target="_blank" rel="noopener">http://company.com/index.html</a>  属于同源并且不受任何限制。<br><strong>源的更改</strong></p>
<p>  页面可能会更改其自己的来源，但有一些限制。脚本可以将 document.domain 的值设置为其当前域或其当前域的超级域。如果将其设置为其当前域的超级域，则较短的域将用于后续原始检查。例如，假设文档中的一个脚本在 <a href="http://store.company.com/dir/other.html" target="_blank" rel="noopener">http://store.company.com/dir/other.html</a> 执行以下语句：</p>
</li>
</ul>
<p><code>document.domain = &quot;company.com&quot;</code></p>
<pre><code>这条语句执行之后，页面将会成功地通过对 http://company.com/dir/page.html 的同源检测。而同理，company.com 不能设置 document.domain 为 othercompany.com.

浏览器单独保存端口号。任何的赋值操作，包括document.domain = document.domain都会以null值覆盖掉原来的端口号。因此company.com:8080页面的脚本不能仅通过设置document.domain = &quot;company.com&quot;就能与company.com通信。赋值时必须带上端口号，以确保端口号不会为null。
</code></pre><p><strong>跨源网络访问</strong></p>
<pre><code>同源策略控制了不同源之间的交互，例如在使用XMLHttpRequest 或 &lt;img&gt; 标签时则会受到同源策略的约束。交互通常分为三类：
</code></pre><ul>
<li>通常允许进行跨域写操作（Cross-origin writes）。例如链接（links），重定向以及表单提交。特定少数的HTTP请求需要添加 preflight。</li>
<li>通常允许跨域资源嵌入（Cross-origin embedding）。之后下面会举例说明。</li>
<li><strong>通常不允许跨域读操作（Cross-origin reads）。</strong>但常可以通过内嵌资源来巧妙的进行读取访问。例如可以读取嵌入图片的高度和宽度，调用内嵌脚本的方法，或availability of an embedded resource.</li>
</ul>
<p><strong>如何允许跨源访问</strong></p>
<pre><code>此段文章转自阮一峰http://www.ruanyifeng.com/blog/2016/04/cors.html

跨域资源共享(CORS)机制允许 Web应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。浏览器支持在 API 容器中（例如 XMLHttpRequest或Fetch）使用 CORS，以降低跨域 HTTP 请求所带来的风险。

浏览器将CORS请求分成两类：简单请求（simplerequest）和非简单请求（not-so-simple request）。
只要同时满足以下两大条件，就属于简单请求。

（1）请求方法是以下三种方法之一：

    1.HEAD
    2.GET
    3.POST

（2）HTTP的头信息不超出以下几种字段：

    1.Accept
    2.Accept-Language
    3.Content-Language
    4.Last-Event-ID
    5.Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

    凡是不同时满足上面两个条件，就属于非简单请求。
</code></pre><p><strong>简单请求</strong></p>
<pre><code>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。

GET /cors HTTP/1.1
Origin: http://www.google.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...

上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。

如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。

如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。

Access-Control-Allow-Origin: http://www.google.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8

上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。    

（1）Access-Control-Allow-Origin
该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。

（2）Access-Control-Allow-Credentials
该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。

（3）Access-Control-Expose-Headers
该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(&apos;FooBar&apos;)可以返回FooBar字段的值。

CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。
</code></pre><p><code>Access-Control-Allow-Credentials: true</code></p>
<pre><code>另一方面，开发者必须在AJAX请求中打开withCredentials属性。
</code></pre><p><code>var xhr = new XMLHttpRequest();xhr.withCredentials = true;</code></p>
<pre><code>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。

但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。
</code></pre><p><code>xhr.withCredentials = false;</code></p>
<pre><code>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。
</code></pre><p><strong>非简单请求</strong></p>
<pre><code>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。

非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求（preflight）。

浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。

下面是一段浏览器的JavaScript脚本。
</code></pre><p><code>var url = &#39;http://api.alice.com/cors&#39;;&lt;br&gt;var xhr = new XMLHttpRequest();&lt;br&gt;xhr.open(&#39;PUT&#39;, url, true);&lt;br&gt;xhr.setRequestHeader(&#39;X-Custom-Header&#39;, &#39;value&#39;);&lt;br&gt;xhr.send();</code></p>
<pre><code>上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。

浏览器发现，这是一个非简单请求，就自动发出一个&quot;预检&quot;请求，要求服务器确认可以这样请求。下面是这个&quot;预检&quot;请求的HTTP头信息。

OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...

&quot;预检&quot;请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。

除了Origin字段，&quot;预检&quot;请求的头信息包括两个特殊字段。

（1）Access-Control-Request-Method
该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。
（2）Access-Control-Request-Headers
该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。
</code></pre><p><strong>预检请求的回应</strong></p>
<pre><code>服务器收到&quot;预检&quot;请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。

HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain

上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。

Access-Control-Allow-Origin: *

如果浏览器否定了&quot;预检&quot;请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。

XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.

服务器回应的其他CORS相关字段如下。

Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000

（1）Access-Control-Allow-Methods
该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。 注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预 检&quot;请求。
（2）Access-Control-Allow-Headers
如果浏览器请求包括Access-Control-Request-Headers字段，则&lt;Access-Control-Allow-He&gt;    &lt;/Access-Control-Allow-He&gt;aders字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，    不限于浏览器在&quot;预检&quot;中请求的字段。
（3）Access-Control-Allow-Credentials
该字段与简单请求时的含义相同。
（4）Access-Control-Max-Age
该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（&lt;1&gt; &lt;/1&gt;728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检  请求。
4.3 浏览器的正常请求和回应
一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，  会有一个Origin头信息字段。服务器的回应，也都会有一个&lt;Access-Control-Allow-Origin&gt;    &lt;/Access-Control-Allow-Origin&gt;头信息字段。

下面是&quot;预检&quot;请求之后，浏览器的正常CORS请求。

PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...

上面头信息的Origin字段是浏览器自动添加的。
下面是服务器正常的回应。

Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。
</code></pre><p><strong>与JSONP比较</strong></p>
<pre><code>CORS与JSONP的使用目的相同，但是比JSONP更强大。

JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/isgonghang/isgonghang.github.io/2017/05/21/浏览器同源策略与CORS跨域/" data-id="cjcrdwy2f000dicvl5v2q6r55" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CSS清除浮动" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/20/CSS清除浮动/" class="article-date">
  <time datetime="2017-05-20T09:19:59.000Z" itemprop="datePublished">2017-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/20/CSS清除浮动/">CSS清除浮动</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>父元素的高度是由子元素撑开的，且子元素设置了浮动，父元素没有设置浮动，子元素脱离了标准的文档流，那么父元素的高度会将其忽略，如果不清除浮动，父元素会出现高度不够，那样如果设置border或者background都得不到正确的解析。</strong></p>
<p>清除浮动的方法：</p>
<p>1.给浮动元素父级加overflow:auto;在IE6中需要加上zoom：1</p>
<p>2.使用：after伪元素(<strong>推荐</strong>)</p>
<pre><code>`.clearfix:after{
   content:&quot;&quot;;
   dispaly:block;
   height:0;
   clear:both;
   visibility:hidden;
}
.clearfix{
   zoom:1;
}`

或是：

`.clearfix:after,.clearfix:before{
   content:&quot;&quot;;
   display:table;
}
.clearfix:after{
   clear:both;
}`
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/isgonghang/isgonghang.github.io/2017/05/20/CSS清除浮动/" data-id="cjcrdwy1p0001icvlyw3xmvtd" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/23/Java初学-安装/">Java初学-安装</a>
          </li>
        
          <li>
            <a href="/2017/09/17/css居中布局总结/">css居中布局总结</a>
          </li>
        
          <li>
            <a href="/2017/08/25/webpack深入与实战/">webpack深入与实战</a>
          </li>
        
          <li>
            <a href="/2017/08/18/JavaScript正则表达式/">JavaScript正则表达式</a>
          </li>
        
          <li>
            <a href="/2017/07/25/学习Javascript闭包/">学习Javascript闭包</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Harris<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>